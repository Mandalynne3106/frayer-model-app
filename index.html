<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frayer Model Vocabulary Builder</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font family -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
            color: #f3f4f6;
        }
        .frayer-quadrant {
            @apply p-4 border border-gray-600 rounded-lg shadow-lg bg-gray-700 h-full flex flex-col;
        }
        .frayer-title {
            @apply text-lg font-semibold mb-2 text-indigo-400;
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8">
    <div id="app" class="max-w-6xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-indigo-400 mb-2">Frayer Model Vocabulary Tool</h1>
            <p class="text-gray-400">Build and review vocabulary entries using the 4-quadrant method. <span class="font-bold text-yellow-300">Shareable!</span></p>
        </header>

        <main class="grid lg:grid-cols-4 gap-6">
            <!-- Left Sidebar: Word List -->
            <div class="lg:col-span-1 bg-gray-800 p-4 rounded-xl shadow-2xl h-full">
                <h2 class="text-2xl font-bold mb-4 border-b border-indigo-500 pb-2">Saved Words</h2>
                <div id="auth-info" class="text-xs text-gray-500 mb-4"></div>
                <div id="word-list" class="space-y-3 max-h-96 overflow-y-auto">
                    <!-- Words will be injected here -->
                    <p id="loading-message" class="text-center text-gray-500">Loading vocabulary...</p>
                </div>
                <div id="error-message" class="hidden mt-4 text-sm p-2 bg-red-800 rounded-lg"></div>
            </div>

            <!-- Main Content: Frayer Model Card & Input Form -->
            <div id="current-display" class="lg:col-span-3 space-y-6">
                <!-- Current Frayer Model Display Card -->
                <div id="frayer-display-card" class="bg-gray-800 p-6 rounded-xl shadow-2xl">
                    <div class="flex justify-between items-center mb-6">
                         <div id="creator-info" class="text-sm text-gray-400"></div>
                         
                         <!-- QUIZ MODE TOGGLE AND BUTTONS -->
                         <div class="flex items-center space-x-4">
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="quiz-mode-toggle" class="sr-only peer">
                                <div class="relative w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                                <span class="ms-3 text-sm font-medium text-gray-300">Quiz Mode</span>
                            </label>
                             <div id="edit-delete-buttons" class="space-x-2 hidden">
                                <button id="edit-button" class="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 text-white text-sm font-bold rounded-lg transition duration-200">Edit</button>
                                <button id="delete-button" class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-sm font-bold rounded-lg transition duration-200">Delete</button>
                             </div>
                         </div>
                    </div>

                    <div id="current-word-title" class="text-center text-5xl font-extrabold mb-6 text-yellow-400 min-h-12 flex items-center justify-center">
                        Select a word or create a new one!
                    </div>
                    
                    <!-- REVEAL BUTTONS CONTAINER -->
                    <div id="reveal-buttons" class="text-center mb-6 space-x-2 hidden flex-wrap justify-center">
                        <button data-quadrant="definition" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Definition</button>
                        <button data-quadrant="characteristics" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Characteristics</button>
                        <button data-quadrant="examples" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Examples</button>
                        <button data-quadrant="nonExamples" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Non-Examples</button>
                    </div>

                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 h-96">
                        <div id="definition" class="frayer-quadrant">
                            <h3 class="frayer-title">1. Definition</h3>
                            <p id="def-content" class="text-gray-300"></p>
                        </div>
                        <div id="characteristics" class="frayer-quadrant">
                            <h3 class="frayer-title">2. Characteristics / Facts</h3>
                            <p id="char-content" class="text-gray-300"></p>
                        </div>
                        <div id="examples" class="frayer-quadrant">
                            <h3 class="frayer-title">3. Examples</h3>
                            <p id="ex-content" class="text-gray-300"></p>
                        </div>
                        <div id="non-examples" class="frayer-quadrant">
                            <h3 class="frayer-title">4. Non-Examples</h3>
                            <p id="non-ex-content" class="text-gray-300"></p>
                        </div>
                    </div>
                </div>

                <!-- Input Form -->
                <div class="bg-gray-800 p-6 rounded-xl shadow-2xl">
                    <h2 class="text-2xl font-bold mb-4 text-indigo-400" id="form-title">Add New Vocabulary Word</h2>
                    <form id="frayer-form" class="space-y-4">
                        <!-- Word Input - Triggers AI Search on blur -->
                        <input type="text" id="word" required placeholder="Vocabulary Word" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500">
                        <input type="hidden" id="entry-id">

                        <!-- AI Definition Output (Read-Only) -->
                        <div id="ai-definition-area" class="space-y-2 p-3 bg-gray-900 border border-gray-700 rounded-lg">
                            <label class="text-gray-400 text-sm block font-medium">Auto-Loaded Definition (AI-Generated)</label>
                            <div id="ai-definition-output" class="text-gray-300 min-h-12">Enter a word above to search...</div>
                            <div id="ai-sources" class="text-xs text-gray-500 mt-2"></div>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <!-- Student's Definition Input (This is what gets saved as Definition) -->
                            <textarea id="student-definition-input" required placeholder="1. Your Definition (What you will save)" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            <textarea id="characteristics-input" required placeholder="2. Characteristics / Facts" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            <textarea id="examples-input" required placeholder="3. Examples" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            <textarea id="non-examples-input" required placeholder="4. Non-Examples" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>

                        <button type="submit" id="save-button" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition duration-200 shadow-md hover:shadow-lg disabled:opacity-50">
                            Save Frayer Entry
                        </button>
                        <button type="button" id="cancel-edit-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition duration-200 shadow-md hidden">
                            Cancel Edit
                        </button>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // IMPORT deleteDoc and updateDoc for editing/deletion functionality
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, serverTimestamp, orderBy, deleteDoc, updateDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL SETUP ---
        // setLogLevel('debug'); // Disable detailed Firebase logging for production version

        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        
        // API Key for LLM calls (left empty string as required)
        const apiKey = "";

        // --- STANDALONE CONFIGURATION ---
        // When running outside the canvas, we use a default setup for Firebase.
        // !!! IMPORTANT: Replace this with your own Firebase project config if you want a permanent, shared database !!!
        // Using a unique ID based on local storage ensures data separation for different users/browsers.
        const APP_ID_KEY = 'frayer_model_app_id';
        let appId = localStorage.getItem(APP_ID_KEY);
        if (!appId) {
            appId = 'standalone-' + crypto.randomUUID();
            localStorage.setItem(APP_ID_KEY, appId);
        }
        
        // THIS IS A MOCK CONFIGURATION. FOR REAL PUBLIC SHARING, YOU NEED A REAL CONFIG.
        // Leaving it empty will cause the app to revert to localStorage/in-memory data.
        const firebaseConfig = {}; 
        
        // DOM Elements
        const wordListEl = document.getElementById('word-list');
        const authInfoEl = document.getElementById('auth-info');
        const errorEl = document.getElementById('error-message');
        const formEl = document.getElementById('frayer-form');
        const loadingMessageEl = document.getElementById('loading-message');
        const aiDefinitionOutputEl = document.getElementById('ai-definition-output');
        const studentDefinitionInputEl = document.getElementById('student-definition-input');
        const aiSourcesEl = document.getElementById('ai-sources');
        const wordInputEl = document.getElementById('word');
        const characteristicsInputEl = document.getElementById('characteristics-input');
        const examplesInputEl = document.getElementById('examples-input');
        const nonExamplesInputEl = document.getElementById('non-examples-input');
        const entryIdInputEl = document.getElementById('entry-id');
        const formTitleEl = document.getElementById('form-title');
        const saveButtonEl = document.getElementById('save-button');
        const cancelEditButtonEl = document.getElementById('cancel-edit-button');
        const creatorInfoEl = document.getElementById('creator-info');
        const editDeleteButtonsEl = document.getElementById('edit-delete-buttons');
        const editButtonEl = document.getElementById('edit-button');
        const deleteButtonEl = document.getElementById('delete-button');
        
        // New Quiz Mode elements and state
        const quizModeToggleEl = document.getElementById('quiz-mode-toggle');
        const revealButtonsContainerEl = document.getElementById('reveal-buttons');
        let isQuizMode = false;
        let revealedState = {}; // Tracks which quadrants are revealed in quiz mode

        let currentSelectedEntry = null; // Store the currently viewed entry data

        // Helper map for displayFrayerCard
        const quadrantMap = {
            definition: 'def-content',
            characteristics: 'char-content',
            examples: 'ex-content',
            nonExamples: 'non-ex-content'
        };

        function displayError(message) {
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => errorEl.classList.add('hidden'), 5000);
        }

        function displayFrayerCard(data) {
            currentSelectedEntry = data; // Set the current entry
            
            // Display data
            document.getElementById('current-word-title').textContent = data.word || 'Word Not Found';

            const isPlaceholder = !data.id; // Check if it's a real entry or a placeholder

            // Quiz Mode visibility logic
            if (isQuizMode && !isPlaceholder) {
                // Initialize revealed state if this is a new word in quiz mode
                if (!revealedState.hasOwnProperty('definition')) {
                    revealedState = {
                        definition: false,
                        characteristics: false,
                        examples: false,
                        nonExamples: false
                    };
                }
                revealButtonsContainerEl.classList.remove('hidden', 'flex-wrap'); // Ensure it's visible and wraps
                revealButtonsContainerEl.classList.add('flex', 'flex-wrap');
            } else {
                // Not in quiz mode OR displaying a placeholder, hide reveal buttons
                revealButtonsContainerEl.classList.add('hidden');
                // Ensure revealedState is reset when exiting quiz mode/changing word
                revealedState = {}; 
            }
            
            // Render all quadrants based on state
            ['definition', 'characteristics', 'examples', 'nonExamples'].forEach(key => {
                const contentEl = document.getElementById(quadrantMap[key]);
                const content = data[key] || `No ${key.replace(/([A-Z])/g, ' $1').toLowerCase()} provided.`;
                const btn = revealButtonsContainerEl.querySelector(`[data-quadrant="${key}"]`);
                
                if (isQuizMode && !isPlaceholder && !revealedState[key]) {
                    // Quiz mode, not revealed: hide content
                    contentEl.textContent = '??? Click "Reveal" above to check your answer ???';
                    contentEl.classList.add('italic', 'text-gray-500');
                    if (btn) btn.classList.remove('hidden');
                    
                } else {
                    // Not quiz mode OR revealed: show content
                    contentEl.textContent = content;
                    contentEl.classList.remove('italic', 'text-gray-500');
                    if (btn) btn.classList.add('hidden');
                }
            });


            // Display creator info
            creatorInfoEl.innerHTML = data.creatorId
                ? `Created by: <span class="font-mono text-xs text-yellow-300">${data.creatorId.substring(0, 8)}...</span>`
                : 'Creator: N/A';

            // Show edit/delete buttons only if the current user created the entry, it's not a placeholder, and quiz mode is OFF
            if (isAuthReady && userId === data.creatorId && !isPlaceholder && !isQuizMode) {
                editDeleteButtonsEl.classList.remove('hidden');
            } else {
                editDeleteButtonsEl.classList.add('hidden');
            }
        }

        function resetForm() {
            formEl.reset();
            entryIdInputEl.value = '';
            formTitleEl.textContent = 'Add New Vocabulary Word';
            saveButtonEl.textContent = 'Save Frayer Entry';
            wordInputEl.disabled = false;
            cancelEditButtonEl.classList.add('hidden');
            
            // Do not reset currentSelectedEntry here, as it might contain the currently viewed word data.
            // Resetting it would break the display if a user clicks cancel.
            
            aiDefinitionOutputEl.textContent = 'Enter a word above to search...';
            aiSourcesEl.textContent = '';
        }

        function loadEntryForEdit(entry) {
            formTitleEl.textContent = `Editing: ${entry.word}`;
            saveButtonEl.textContent = 'Update Entry';
            entryIdInputEl.value = entry.id;
            wordInputEl.value = entry.word;
            wordInputEl.disabled = true; // Prevent editing the word itself during an update
            studentDefinitionInputEl.value = entry.definition;
            characteristicsInputEl.value = entry.characteristics;
            examplesInputEl.value = entry.examples;
            nonExamplesInputEl.value = entry.nonExamples;
            cancelEditButtonEl.classList.remove('hidden');
            // Clear AI area since we're editing
            aiDefinitionOutputEl.textContent = 'Editing existing entry.';
            aiSourcesEl.textContent = '';
            
            // Hide edit/delete buttons when form is open for editing
            editDeleteButtonsEl.classList.add('hidden');
        }

        // --- FIREBASE INITIALIZATION AND AUTH ---
        if (Object.keys(firebaseConfig).length > 0) {
            // Standard Firebase initialization (same as before)
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // 1. Listen for auth state changes:
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    authInfoEl.textContent = `User ID: ${userId}`;
                    isAuthReady = true;
                    // Once authenticated, start listening for data
                    subscribeToVocabulary();
                } else {
                    console.log("Auth state changed: No active user. Waiting for sign-in process to complete.");
                }
            });

            // 2. Initial Sign-in Trigger: Use Anonymous sign-in for standalone mode
            (async () => {
                if (!auth.currentUser) {
                    try {
                        await signInAnonymously(auth);
                        console.log("Signed in anonymously.");
                    } catch (error) {
                        console.error("Initial Authentication failed:", error);
                        displayError("Authentication failed. Data persistence disabled.");
                    }
                }
            })();

        } else {
            // --- OFFLINE/MOCK DATABASE FALLBACK (New for standalone) ---
            displayError("Warning: Firebase config not found. Data is not persistent and will only be saved locally in this browser.");
            loadingMessageEl.textContent = "Offline Mode: Data is NOT shared or permanently saved.";
            isAuthReady = true;
            userId = 'local-user'; // Mock user ID for local mode
            authInfoEl.textContent = `User ID: ${userId} (Local)`;
            
            // Mock database implementation using localStorage
            const LOCAL_STORAGE_KEY = 'frayer_model_local_data';
            let localData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            
            // Mock Firestore functions
            function getCollectionRef() { return 'local'; }
            function subscribeToVocabulary() {
                // Simulate initial load
                updateWordList(localData);
            }
            
            // Mock onSnapshot handler for local data
            function updateWordList(data) {
                loadingMessageEl.classList.add('hidden');
                wordListEl.innerHTML = '';
                const vocabulary = data;
                
                // Sort locally by a 'timestamp' property if it exists, simulating Firestore orderBy
                vocabulary.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

                vocabulary.forEach((entry) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'p-3 bg-gray-700 hover:bg-indigo-600 rounded-lg cursor-pointer transition duration-150 shadow-md';
                    
                    const creatorPrefix = entry.creatorId ? `<span class="font-mono text-xs text-yellow-400"> (${entry.creatorId.substring(0, 4)}...)</span>` : '';
                    listItem.innerHTML = `<strong>${entry.word}</strong>${creatorPrefix}`;
                    
                    listItem.onclick = () => {
                        revealedState = {}; 
                        displayFrayerCard(entry);
                    }
                    wordListEl.appendChild(listItem);
                });
                
                if (vocabulary.length === 0) {
                    wordListEl.innerHTML = '<p class="text-gray-500 p-2">No words saved yet. Add one above!</p>';
                    displayFrayerCard({ word: 'No words saved yet.' }); 
                } else if (vocabulary.length > 0 && !currentSelectedEntry) {
                    displayFrayerCard(vocabulary[0]);
                }
                
                // Save the data back to localStorage
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(vocabulary));
                localData = vocabulary;
            }

            async function saveFrayerEntry(data, entryId) {
                const now = Date.now();
                const newEntry = {
                    word: data.word,
                    definition: data.definition,
                    characteristics: data.characteristics,
                    examples: data.examples,
                    nonExamples: data.nonExamples,
                };
                
                if (entryId) {
                    // Update existing entry
                    const index = localData.findIndex(e => e.id === entryId);
                    if (index !== -1) {
                        localData[index] = { ...localData[index], ...newEntry, updatedAt: now };
                    }
                } else {
                    // Add new entry
                    const id = 'doc_' + now;
                    localData.push({ id, ...newEntry, timestamp: now, creatorId: userId });
                }
                updateWordList(localData);
            }

            async function deleteFrayerEntry(entryId) {
                if (!confirm(`Are you sure you want to delete this word entry?`)) {
                    return;
                }
                localData = localData.filter(e => e.id !== entryId);
                updateWordList(localData);
                displayFrayerCard({ word: 'Select a word or create a new one!' });
                editDeleteButtonsEl.classList.add('hidden');
            }
            
            // Start the local subscription
            subscribeToVocabulary();
        }


        // --- LLM API FUNCTION FOR DEFINITION LOOKUP (Remains the same) ---

        async function fetchDefinition(word) {
            // ... (LLM code remains the same, it doesn't rely on Firebase context) ...
            if (!word || entryIdInputEl.value) { // Don't search if we are editing
                if (!entryIdInputEl.value) {
                    aiDefinitionOutputEl.textContent = 'Enter a word above to search...';
                    aiSourcesEl.textContent = '';
                }
                return;
            }

            aiDefinitionOutputEl.textContent = 'Searching for a precise dictionary definition...';
            aiSourcesEl.textContent = '...';

            const systemPrompt = "Act as a formal, precise lexicographer. Given a vocabulary word, provide a single, concise definition that is clear, objective, and styled like a modern dictionary entry (starting directly with the definition, not a conversational opening). Do not include the word itself in the output, and keep it appropriate for general usage. Do not include a title or markdown headings.";
            const userQuery = `Define the vocabulary word: "${word}"`;
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            const maxRetries = 5;
            let delay = 1000;

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2; // Exponential backoff
                            continue;
                        }
                        throw new Error(`API response error: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        aiDefinitionOutputEl.textContent = text;
                        aiSourcesEl.textContent = ''; // Clear previous loading text

                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            const sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title);

                            if (sources.length > 0) {
                                aiSourcesEl.innerHTML = 'Source(s): ' + sources.map(s =>
                                    `<a href="${s.uri}" target="_blank" class="text-blue-400 hover:text-blue-300 underline">${s.title}</a>`
                                ).join(', ');
                            } else {
                                aiSourcesEl.textContent = 'No specific web sources cited.';
                            }
                        }
                        return;
                    } else {
                        aiDefinitionOutputEl.textContent = 'Could not generate a definition for that word.';
                        aiSourcesEl.textContent = '';
                        return;
                    }

                } catch (error) {
                    console.error("LLM API Call failed:", error);
                    if (i === maxRetries - 1) {
                        aiDefinitionOutputEl.textContent = `Error: Failed to fetch definition after ${maxRetries} attempts.`;
                        aiSourcesEl.textContent = '';
                    }
                }
            }
        }

        // --- EVENT LISTENERS (Remain the same, referencing the now-scoped save/delete functions) ---
        
        // Bind fetchDefinition to the word input's blur event
        wordInputEl.addEventListener('blur', (e) => {
            fetchDefinition(e.target.value.trim());
        });

        // Edit button listener
        editButtonEl.addEventListener('click', () => {
            if (currentSelectedEntry) {
                loadEntryForEdit(currentSelectedEntry);
            }
        });

        // Delete button listener
        deleteButtonEl.addEventListener('click', () => {
            if (currentSelectedEntry) {
                // Use a simple custom confirmation instead of alert/confirm
                if (confirm('Are you sure you want to delete this entry? This action cannot be undone.')) {
                    deleteFrayerEntry(currentSelectedEntry.id);
                }
            }
        });
        
        // Cancel button listener
        cancelEditButtonEl.addEventListener('click', (e) => {
             e.preventDefault();
             resetForm();
             // Re-display the card to ensure creator buttons are correct if a word was selected
             if (currentSelectedEntry) displayFrayerCard(currentSelectedEntry);
        });


        formEl.addEventListener('submit', async (e) => {
            e.preventDefault();
            const entryId = entryIdInputEl.value; // Check if we are editing (has ID)
            const saveButton = document.getElementById('save-button');
            saveButton.disabled = true;

            const word = wordInputEl.value.trim();
            const definition = studentDefinitionInputEl.value.trim();
            const characteristics = characteristicsInputEl.value.trim();
            const examples = examplesInputEl.value.trim();
            const nonExamples = nonExamplesInputEl.value.trim();

            if (word && definition && characteristics && examples && nonExamples) {
                const newEntry = { word, definition, characteristics, examples, nonExamples };
                
                await saveFrayerEntry(newEntry, entryId);

                // Clear form inputs and AI output
                resetForm();
            } else {
                displayError("All fields must be filled out to save an entry.");
            }

            saveButton.disabled = false;
        });
        
        // Quiz Mode Toggle Listener
        quizModeToggleEl.addEventListener('change', () => {
            isQuizMode = quizModeToggleEl.checked;
            
            // If we are currently viewing an entry, re-display it to apply quiz mode
            if (currentSelectedEntry && currentSelectedEntry.word && currentSelectedEntry.word !== 'Select a word or create a new one!' && currentSelectedEntry.word !== 'No words saved yet.') {
                // When toggling, reset the revealed state to start the quiz fresh
                revealedState = {}; 
                displayFrayerCard(currentSelectedEntry);
            } else {
                // If quiz mode is off or no word is selected, just hide buttons
                editDeleteButtonsEl.classList.add('hidden');
                revealButtonsContainerEl.classList.add('hidden');
            }
            
            // Always reset the input form when toggling quiz mode
            resetForm();
        });

        // Reveal Button Listener
        revealButtonsContainerEl.addEventListener('click', (e) => {
            const quadrant = e.target.getAttribute('data-quadrant');
            if (quadrant && isQuizMode && currentSelectedEntry) {
                revealedState[quadrant] = true;
                // Re-display the card to show the revealed content
                displayFrayerCard(currentSelectedEntry);
            }
        });

    </script>
</body>
</html>