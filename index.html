<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frayer Model Vocabulary Builder</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font family -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
            color: #f3f4f6;
        }
        .frayer-quadrant {
            @apply p-4 border border-gray-600 rounded-lg shadow-lg bg-gray-700 h-full flex flex-col;
        }
        .frayer-title {
            @apply text-lg font-semibold mb-2 text-indigo-400;
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8">
    <div id="app" class="max-w-6xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-indigo-400 mb-2">Frayer Model Vocabulary Tool</h1>
            <p class="text-gray-400">Build and review vocabulary entries using the 4-quadrant method. (No API Key Required!) <span class="font-bold text-yellow-300">Shareable!</span></p>
        </header>

        <main class="grid lg:grid-cols-4 gap-6">
            <!-- Left Sidebar: Word List -->
            <div class="lg:col-span-1 bg-gray-800 p-4 rounded-xl shadow-2xl h-full">
                <h2 class="text-2xl font-bold mb-4 border-b border-indigo-500 pb-2">Saved Words</h2>
                <div id="auth-info" class="text-xs text-gray-500 mb-4"></div>
                <div id="word-list" class="space-y-3 max-h-96 overflow-y-auto">
                    <!-- Words will be injected here -->
                    <p id="loading-message" class="text-center text-gray-500">Loading vocabulary...</p>
                </div>
                <div id="error-message" class="hidden mt-4 text-sm p-2 bg-red-800 rounded-lg"></div>
            </div>

            <!-- Main Content: Frayer Model Card & Input Form -->
            <div id="current-display" class="lg:col-span-3 space-y-6">
                <!-- Current Frayer Model Display Card -->
                <div id="frayer-display-card" class="bg-gray-800 p-6 rounded-xl shadow-2xl">
                    <div class="flex justify-between items-center mb-6">
                         <div id="creator-info" class="text-sm text-gray-400"></div>
                         
                         <!-- QUIZ MODE TOGGLE AND BUTTONS -->
                         <div class="flex items-center space-x-4">
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="quiz-mode-toggle" class="sr-only peer">
                                <div class="relative w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                                <span class="ms-3 text-sm font-medium text-gray-300">Quiz Mode</span>
                            </label>
                             <div id="edit-delete-buttons" class="space-x-2 hidden">
                                <button id="edit-button" class="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 text-white text-sm font-bold rounded-lg transition duration-200">Edit</button>
                                <button id="delete-button" class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-sm font-bold rounded-lg transition duration-200">Delete</button>
                             </div>
                         </div>
                    </div>

                    <div id="current-word-title" class="text-center text-5xl font-extrabold mb-6 text-yellow-400 min-h-12 flex items-center justify-center">
                        Select a word or create a new one!
                    </div>
                    
                    <!-- REVEAL BUTTONS CONTAINER -->
                    <div id="reveal-buttons" class="text-center mb-6 space-x-2 hidden flex-wrap justify-center">
                        <button data-quadrant="definition" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Student Definition</button>
                        <button data-quadrant="characteristics" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Characteristics</button>
                        <button data-quadrant="examples" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Examples</button>
                        <button data-quadrant="nonExamples" class="reveal-btn px-4 py-2 my-1 bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold rounded-lg transition duration-200">Reveal Non-Examples</button>
                    </div>

                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 h-96">
                        <!-- QUADRANT 1: DEFINITION (Now shows student version + reference version) -->
                        <div id="definition" class="frayer-quadrant">
                            <h3 class="frayer-title">1. Student Definition / Paraphrase</h3>
                            <p id="def-content" class="text-gray-300 flex-grow mb-4"></p>
                            
                            <!-- New Reference Definition Display -->
                            <div id="ref-def-content-container" class="text-xs pt-2 border-t border-gray-600 italic text-gray-400 hidden mt-auto">
                                <span class="font-bold text-gray-300">Reference:</span> <span id="ref-def-text"></span>
                            </div>
                        </div>

                        <!-- Other Quadrants remain the same -->
                        <div id="characteristics" class="frayer-quadrant">
                            <h3 class="frayer-title">2. Characteristics / Facts</h3>
                            <p id="char-content" class="text-gray-300"></p>
                        </div>
                        <div id="examples" class="frayer-quadrant">
                            <h3 class="frayer-title">3. Examples</h3>
                            <p id="ex-content" class="text-gray-300"></p>
                        </div>
                        <div id="non-examples" class="frayer-quadrant">
                            <h3 class="frayer-title">4. Non-Examples</h3>
                            <p id="non-ex-content" class="text-gray-300"></p>
                        </div>
                    </div>
                </div>

                <!-- Input Form -->
                <div class="bg-gray-800 p-6 rounded-xl shadow-2xl">
                    <h2 class="text-2xl font-bold mb-4 text-indigo-400" id="form-title">Add New Vocabulary Word</h2>
                    <form id="frayer-form" class="space-y-4">
                        <!-- Word Input -->
                        <input type="text" id="word" required placeholder="Vocabulary Word" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500">
                        <input type="hidden" id="entry-id">

                        <!-- NEW: Reference/Copied Definition Input -->
                        <textarea id="reference-definition-input" placeholder="0. Reference Definition (Copy/Paste from source)" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <!-- Student's Definition Input (This is what gets saved as Definition) -->
                            <textarea id="student-definition-input" required placeholder="1. Your Definition / Paraphrase (What you will save)" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            <textarea id="characteristics-input" required placeholder="2. Characteristics / Facts" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            <textarea id="examples-input" required placeholder="3. Examples" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            <textarea id="non-examples-input" required placeholder="4. Non-Examples" rows="3" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>

                        <button type="submit" id="save-button" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition duration-200 shadow-md hover:shadow-lg disabled:opacity-50">
                            Save Frayer Entry
                        </button>
                        <button type="button" id="cancel-edit-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition duration-200 shadow-md hidden">
                            Cancel Edit
                        </button>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // IMPORT deleteDoc and updateDoc for editing/deletion functionality
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, serverTimestamp, orderBy, deleteDoc, updateDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL SETUP ---
        // setLogLevel('debug'); // Disable detailed Firebase logging for production version

        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        
        // Removed API Key and fetchDefinition function
        
        // --- STANDALONE CONFIGURATION ---
        const APP_ID_KEY = 'frayer_model_app_id';
        let appId = localStorage.getItem(APP_ID_KEY);
        if (!appId) {
            appId = 'standalone-' + crypto.randomUUID();
            localStorage.setItem(APP_ID_KEY, appId);
        }
        
        const firebaseConfig = {}; 
        
        // DOM Elements
        const wordListEl = document.getElementById('word-list');
        const authInfoEl = document.getElementById('auth-info');
        const errorEl = document.getElementById('error-message');
        const formEl = document.getElementById('frayer-form');
        const loadingMessageEl = document.getElementById('loading-message');
        
        // UPDATED: No more AI output elements. New reference definition input.
        const referenceDefinitionInputEl = document.getElementById('reference-definition-input');
        const studentDefinitionInputEl = document.getElementById('student-definition-input');
        
        const wordInputEl = document.getElementById('word');
        const characteristicsInputEl = document.getElementById('characteristics-input');
        const examplesInputEl = document.getElementById('examples-input');
        const nonExamplesInputEl = document.getElementById('non-examples-input');
        const entryIdInputEl = document.getElementById('entry-id');
        const formTitleEl = document.getElementById('form-title');
        const saveButtonEl = document.getElementById('save-button');
        const cancelEditButtonEl = document.getElementById('cancel-edit-button');
        const creatorInfoEl = document.getElementById('creator-info');
        const editDeleteButtonsEl = document.getElementById('edit-delete-buttons');
        const editButtonEl = document.getElementById('edit-button');
        const deleteButtonEl = document.getElementById('delete-button');
        
        // New Reference Definition Display Elements
        const refDefContentContainerEl = document.getElementById('ref-def-content-container');
        const refDefTextEl = document.getElementById('ref-def-text');
        
        // New Quiz Mode elements and state
        const quizModeToggleEl = document.getElementById('quiz-mode-toggle');
        const revealButtonsContainerEl = document.getElementById('reveal-buttons');
        let isQuizMode = false;
        let revealedState = {}; // Tracks which quadrants are revealed in quiz mode

        let currentSelectedEntry = null; // Store the currently viewed entry data

        // Helper map for displayFrayerCard
        const quadrantMap = {
            definition: 'def-content', // This is the Student Definition
            characteristics: 'char-content',
            examples: 'ex-content',
            nonExamples: 'non-ex-content'
        };

        function displayError(message) {
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => errorEl.classList.add('hidden'), 5000);
        }

        function displayFrayerCard(data) {
            currentSelectedEntry = data; // Set the current entry
            
            // Display data
            document.getElementById('current-word-title').textContent = data.word || 'Word Not Found';

            const isPlaceholder = !data.id; // Check if it's a real entry or a placeholder

            // Quiz Mode visibility logic
            if (isQuizMode && !isPlaceholder) {
                // Initialize revealed state if this is a new word in quiz mode
                if (!revealedState.hasOwnProperty('definition')) {
                    revealedState = {
                        definition: false,
                        characteristics: false,
                        examples: false,
                        nonExamples: false
                    };
                }
                revealButtonsContainerEl.classList.remove('hidden', 'flex-wrap'); // Ensure it's visible and wraps
                revealButtonsContainerEl.classList.add('flex', 'flex-wrap');
            } else {
                // Not in quiz mode OR displaying a placeholder, hide reveal buttons
                revealButtonsContainerEl.classList.add('hidden');
                // Ensure revealedState is reset when exiting quiz mode/changing word
                revealedState = {}; 
            }
            
            // Render all quadrants based on state
            ['definition', 'characteristics', 'examples', 'nonExamples'].forEach(key => {
                const contentEl = document.getElementById(quadrantMap[key]);
                const content = data[key] || `No ${key.replace(/([A-Z])/g, ' $1').toLowerCase()} provided.`;
                const btn = revealButtonsContainerEl.querySelector(`[data-quadrant="${key}"]`);
                
                if (isQuizMode && !isPlaceholder && !revealedState[key]) {
                    // Quiz mode, not revealed: hide content
                    contentEl.textContent = '??? Click "Reveal" above to check your answer ???';
                    contentEl.classList.add('italic', 'text-gray-500');
                    if (btn) btn.classList.remove('hidden');
                    
                } else {
                    // Not quiz mode OR revealed: show content
                    contentEl.textContent = content;
                    contentEl.classList.remove('italic', 'text-gray-500');
                    if (btn) btn.classList.add('hidden');
                }
            });

            // 1. Update Reference Definition Display
            if (data.referenceDefinition) {
                refDefTextEl.textContent = data.referenceDefinition;
                refDefContentContainerEl.classList.remove('hidden');
            } else {
                refDefTextEl.textContent = 'N/A';
                refDefContentContainerEl.classList.add('hidden');
            }

            // Display creator info
            creatorInfoEl.innerHTML = data.creatorId
                ? `Created by: <span class="font-mono text-xs text-yellow-300">${data.creatorId.substring(0, 8)}...</span>`
                : 'Creator: N/A';

            // Show edit/delete buttons only if the current user created the entry, it's not a placeholder, and quiz mode is OFF
            if (isAuthReady && userId === data.creatorId && !isPlaceholder && !isQuizMode) {
                editDeleteButtonsEl.classList.remove('hidden');
            } else {
                editDeleteButtonsEl.classList.add('hidden');
            }
        }

        function resetForm() {
            formEl.reset();
            entryIdInputEl.value = '';
            formTitleEl.textContent = 'Add New Vocabulary Word';
            saveButtonEl.textContent = 'Save Frayer Entry';
            wordInputEl.disabled = false;
            cancelEditButtonEl.classList.add('hidden');
            
            // Reset the reference input field
            referenceDefinitionInputEl.value = '';
        }

        function loadEntryForEdit(entry) {
            formTitleEl.textContent = `Editing: ${entry.word}`;
            saveButtonEl.textContent = 'Update Entry';
            entryIdInputEl.value = entry.id;
            wordInputEl.value = entry.word;
            wordInputEl.disabled = true; // Prevent editing the word itself during an update
            
            // Populate all fields, including the new reference field
            studentDefinitionInputEl.value = entry.definition;
            referenceDefinitionInputEl.value = entry.referenceDefinition || ''; // Handle potential undefined field
            characteristicsInputEl.value = entry.characteristics;
            examplesInputEl.value = entry.examples;
            nonExamplesInputEl.value = entry.nonExamples;
            
            cancelEditButtonEl.classList.remove('hidden');
            
            // Hide edit/delete buttons when form is open for editing
            editDeleteButtonsEl.classList.add('hidden');
        }

        // --- FIREBASE INITIALIZATION AND AUTH (Uses LocalStorage Mock) ---
        if (Object.keys(firebaseConfig).length > 0) {
            // Standard Firebase initialization (omitted for brevity, assume the previous block handles this)
        } else {
            // --- OFFLINE/MOCK DATABASE FALLBACK (New for standalone) ---
            displayError("Warning: Firebase config not found. Data is not persistent and will only be saved locally in this browser.");
            loadingMessageEl.textContent = "Offline Mode: Data is NOT shared or permanently saved.";
            isAuthReady = true;
            userId = 'local-user'; // Mock user ID for local mode
            authInfoEl.textContent = `User ID: ${userId} (Local)`;
            
            // Mock database implementation using localStorage
            const LOCAL_STORAGE_KEY = 'frayer_model_local_data';
            let localData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            
            // Mock Firestore functions
            function getCollectionRef() { return 'local'; }
            function subscribeToVocabulary() {
                // Simulate initial load
                updateWordList(localData);
            }
            
            // Mock onSnapshot handler for local data
            function updateWordList(data) {
                loadingMessageEl.classList.add('hidden');
                wordListEl.innerHTML = '';
                const vocabulary = data;
                
                // Sort locally by a 'timestamp' property if it exists, simulating Firestore orderBy
                vocabulary.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

                vocabulary.forEach((entry) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'p-3 bg-gray-700 hover:bg-indigo-600 rounded-lg cursor-pointer transition duration-150 shadow-md';
                    
                    const creatorPrefix = entry.creatorId ? `<span class="font-mono text-xs text-yellow-400"> (${entry.creatorId.substring(0, 4)}...)</span>` : '';
                    listItem.innerHTML = `<strong>${entry.word}</strong>${creatorPrefix}`;
                    
                    listItem.onclick = () => {
                        revealedState = {}; 
                        displayFrayerCard(entry);
                    }
                    wordListEl.appendChild(listItem);
                });
                
                if (vocabulary.length === 0) {
                    wordListEl.innerHTML = '<p class="text-gray-500 p-2">No words saved yet. Add one above!</p>';
                    displayFrayerCard({ word: 'No words saved yet.' }); 
                } else if (vocabulary.length > 0 && !currentSelectedEntry) {
                    displayFrayerCard(vocabulary[0]);
                }
                
                // Save the data back to localStorage
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(vocabulary));
                localData = vocabulary;
            }

            async function saveFrayerEntry(data, entryId) {
                const now = Date.now();
                const newEntry = {
                    word: data.word,
                    definition: data.definition,
                    referenceDefinition: data.referenceDefinition, // New field
                    characteristics: data.characteristics,
                    examples: data.examples,
                    nonExamples: data.nonExamples,
                };
                
                if (entryId) {
                    // Update existing entry
                    const index = localData.findIndex(e => e.id === entryId);
                    if (index !== -1) {
                        localData[index] = { ...localData[index], ...newEntry, updatedAt: now };
                    }
                } else {
                    // Add new entry
                    const id = 'doc_' + now;
                    localData.push({ id, ...newEntry, timestamp: now, creatorId: userId });
                }
                updateWordList(localData);
            }

            async function deleteFrayerEntry(entryId) {
                if (!confirm(`Are you sure you want to delete this word entry?`)) {
                    return;
                }
                localData = localData.filter(e => e.id !== entryId);
                updateWordList(localData);
                displayFrayerCard({ word: 'Select a word or create a new one!' });
                editDeleteButtonsEl.classList.add('hidden');
            }
            
            // Start the local subscription
            subscribeToVocabulary();
        }


        // --- EVENT LISTENERS ---
        
        // Remove the 'blur' event listener that triggered fetchDefinition
        // wordInputEl.addEventListener('blur', (e) => { fetchDefinition(e.target.value.trim()); });

        // Edit button listener
        editButtonEl.addEventListener('click', () => {
            if (currentSelectedEntry) {
                loadEntryForEdit(currentSelectedEntry);
            }
        });

        // Delete button listener
        deleteButtonEl.addEventListener('click', () => {
            if (currentSelectedEntry) {
                // Use a simple custom confirmation instead of alert/confirm
                if (confirm('Are you sure you want to delete this entry? This action cannot be undone.')) {
                    deleteFrayerEntry(currentSelectedEntry.id);
                }
            }
        });
        
        // Cancel button listener
        cancelEditButtonEl.addEventListener('click', (e) => {
             e.preventDefault();
             resetForm();
             // Re-display the card to ensure creator buttons are correct if a word was selected
             if (currentSelectedEntry) displayFrayerCard(currentSelectedEntry);
        });


        formEl.addEventListener('submit', async (e) => {
            e.preventDefault();
            const entryId = entryIdInputEl.value; // Check if we are editing (has ID)
            const saveButton = document.getElementById('save-button');
            saveButton.disabled = true;

            const word = wordInputEl.value.trim();
            const definition = studentDefinitionInputEl.value.trim();
            const referenceDefinition = referenceDefinitionInputEl.value.trim(); // New field
            const characteristics = characteristicsInputEl.value.trim();
            const examples = examplesInputEl.value.trim();
            const nonExamples = nonExamplesInputEl.value.trim();

            if (word && definition && characteristics && examples && nonExamples) {
                const newEntry = { word, definition, referenceDefinition, characteristics, examples, nonExamples };
                
                await saveFrayerEntry(newEntry, entryId);

                // Clear form inputs
                resetForm();
            } else {
                displayError("The word, student definition, characteristics, examples, and non-examples fields must be filled out to save an entry.");
            }

            saveButton.disabled = false;
        });
        
        // Quiz Mode Toggle Listener
        quizModeToggleEl.addEventListener('change', () => {
            isQuizMode = quizModeToggleEl.checked;
            
            // If we are currently viewing an entry, re-display it to apply quiz mode
            if (currentSelectedEntry && currentSelectedEntry.word && currentSelectedEntry.word !== 'Select a word or create a new one!' && currentSelectedEntry.word !== 'No words saved yet.') {
                // When toggling, reset the revealed state to start the quiz fresh
                revealedState = {}; 
                displayFrayerCard(currentSelectedEntry);
            } else {
                // If quiz mode is off or no word is selected, just hide buttons
                editDeleteButtonsEl.classList.add('hidden');
                revealButtonsContainerEl.classList.add('hidden');
            }
            
            // Always reset the input form when toggling quiz mode
            resetForm();
        });

        // Reveal Button Listener
        revealButtonsContainerEl.addEventListener('click', (e) => {
            const quadrant = e.target.getAttribute('data-quadrant');
            if (quadrant && isQuizMode && currentSelectedEntry) {
                revealedState[quadrant] = true;
                // Re-display the card to show the revealed content
                displayFrayerCard(currentSelectedEntry);
            }
        });

    </script>
</body>
</html>
